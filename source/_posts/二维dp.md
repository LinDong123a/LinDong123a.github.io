---
title: 二维dp
date: 2018-01-07 13:13:46
tags: algorithm
---

想写这个主要是因为在写OJ被一道题目莫名坑了N久，直到后面后知后觉才发现是我之前把dp理解错了，导致我的状态转移设定出现了问题，在这里记录一下，省得自己一天老犯傻。

#### 问题描述

给定一个环形数组，要求你在这其中找$\leq$3个子序列，使其和最大。

<!-- more -->

#### 分析

这里其实可以很简单地想到用动态规划来完成，然而，当时记错了一维动态规划的我活生生死在了状态转移方程的列写上，然后生命就这样过去了。
至于环形数组倒是满好解决的，让动态规划的时候，第一次一定包含第一个元素即可，这样时间复杂度也没高多少。

#### 二维dp

对于动态规划而言，个人认为比较重要的是找到一个状态转换方程，动态地更新局部最优解，从而得到最后的全局最优解。
首先就上述题目而言，对于第n段的第i个元素时，要找到此时对应的最优解，我们要考虑如下情况:

1.  将该元素直接接入到第n段的第i-1个元素后面
2. 将该元素自己成为第n段，同时遍历前n-1段与其相加

通过比较上述两种情况，我们动态地更新其该元素的大小。但按照这种方式进行更新的话，我们会发现，这样在时间和空间上都有比较大的消耗，因此我们还需要对上述算法进行二次优化。

通过回溯算法，我们发现，在考虑该元素自成一段的情况下，我们问题需要往前遍历n-1次来进行最大值的查找，但是该过程是与n无关的，也就是说，我们完成可以定义一个数组max来保留前n-1段下的最大值 ，这样我们就不需要记录前n-1段的全部信息，实现时间和空间上的改善。

参考代码如下:

```C++
int max[100];
int dp[100];
int input[100];

for(int i = 1; i < 100; i++) {
  int max_value = -10000;
  
  for(int j = 1; j < 100; j++) {
    dp[j] = Max(dp[j-1]+input[j], max[j-1]+input[j]);
    
    max[j-1] = max_value;
    max_value = Max(dp[j], max[j]);
  }
}
```

**tips: 上面为了使代码的统一性，我多开辟了一个空间来使数组的计数从1开始，这样就不用简单是否为0然后单独处理了.**